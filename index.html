<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü™ê</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lipis/flag-icons@7.5.0/css/flag-icons.min.css">
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script type="module">
        import { animate, stagger } from "https://cdn.jsdelivr.net/npm/motion@10/dist/motion.es.js";
        window.motion = { animate, stagger };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000011;
            overflow: hidden;
            cursor: crosshair;
            font-family: Arial, sans-serif;
        }

        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            color: #00ffff;
            font-size: 2rem;
            text-shadow: 0 0 10px #00ffff;
            user-select: none;
        }

        .country-info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            color: #ffffff;
            text-align: center;
            font-size: 1.2rem;
            text-shadow: 0 0 10px #000000;
        }

        .leaderboard {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(0, 0, 17, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0 0 20px 20px;
            border-top: none;
            width: 400px;
            overflow: hidden;
            backdrop-filter: blur(20px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
        }

        .leaderboard.collapsed {
            height: auto;
        }

        .leaderboard.collapsed .leaderboard-content,
        .leaderboard.collapsed .leaderboard-header {
            max-height: 0;
            padding: 0;
            overflow: hidden;
        }

        .leaderboard-toggle {
            position: relative;
            margin: 6px auto;
            background: rgba(0, 255, 255, 0.8);
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: #000;
            transition: all 0.3s ease;
            z-index: 1001;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .leaderboard-toggle:hover {
            background: rgba(0, 255, 255, 1);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.4);
        }

        .leaderboard-header {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(0, 255, 255, 0.05));
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .leaderboard h3 {
            color: #ffffff;
            text-align: center;
            margin: 0;
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .leaderboard-preview {
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .leaderboard-preview-left {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .leaderboard-preview-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .top-country {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #ffd700;
        }

        .leaderboard-header {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(0, 255, 255, 0.05));
            padding: 12px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .leaderboard-content {
            max-height: 400px;
            overflow-y: auto;
            padding: 8px 0;
            transition: all 0.3s ease;
        }

        .leaderboard-content::-webkit-scrollbar {
            width: 6px;
        }

        .leaderboard-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .leaderboard-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
        }

        .leaderboard-row {
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .leaderboard-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .leaderboard-row.user-country {
            background: rgba(0, 255, 255, 0.1);
            border-left: 3px solid #00ffff;
        }

        .leaderboard-row.user-country:hover {
            background: rgba(0, 255, 255, 0.15);
        }

        .leaderboard-cell {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.9rem;
        }

        .rank-cell {
            width: 50px;
            text-align: center;
            font-weight: 700;
            font-size: 1.2rem;
            color: #ffffff;
        }

        .rank-cell.gold { color: #ffd700; }
        .rank-cell.silver { color: #c0c0c0; }
        .rank-cell.bronze { color: #cd7f32; }

        .country-cell {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 0;
        }

        .country-flag {
            width: 24px;
            height: 18px;
            border-radius: 3px;
            flex-shrink: 0;
            overflow: hidden;
        }

        .country-name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .score-cell {
            text-align: right;
            font-weight: 600;
            color: #00ffff;
            white-space: nowrap;
            width: 80px;
        }

        .loading-state {
            padding: 40px 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }

        .mute-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: none;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .mute-btn:hover {
            opacity: 1;
        }

        .emoji-explosion {
            position: fixed;
            font-size: 3rem;
            pointer-events: none;
            z-index: 999;
        }

        .social-links {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .social-links a {
                font-size: 2rem;
            text-decoration: none;
            opacity: 0.7;
            transition: all 0.3s;
        }

        .social-links a:hover {
            opacity: 1;
            transform: scale(1.2);
        }

        .trading-links {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            max-width: 600px;
        }

        .trading-links .link-item {
            display: block;
            width: var(--desktop-icon-size, 40px);
            height: var(--desktop-icon-size, 40px);
            border-radius: 8px;
            overflow: hidden;
            opacity: 0.8;
            transition: all 0.3s;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .trading-links .link-item:hover {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
        }

        .trading-links .link-item:hover .tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(-10px);
        }

        .trading-links img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-5px);
            background: rgba(0, 0, 0, 0.9);
            color: #ffffff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
            z-index: 1001;
            pointer-events: none;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 4px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
        }

        .ca-button {
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 0.9rem;
            color: #00ffff;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.1));
            border: 2px solid rgba(0, 255, 255, 0.4);
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
        }

        .ca-button:hover {
            color: #ffffff;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.4), rgba(0, 255, 255, 0.2));
            border-color: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
        }

        .ca-button:active {
            transform: scale(0.95);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
        }

        .copy-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 255, 0.9);
            color: #000;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .loading {
            color: #888;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .hud {
                font-size: 1.5rem;
            }
            .leaderboard {
                width: 250px;
                right: 10px;
                top: 10px;
            }
            .country-info {
                top: 10px;
                font-size: 1rem;
            }
            .social-links {
                top: 50%;
                right: 10px;
                transform: translateY(-50%);
            }
            .social-links a {
                font-size: 1.5rem;
            }
            .trading-links {
                bottom: 15px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 90vw;
            }
            .trading-links .link-item {
                width: var(--mobile-icon-size, 35px);
                height: var(--mobile-icon-size, 35px);
            }
        }
    </style>
</head>
<body>
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
        import { getDatabase, ref, set, get, onValue, increment } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js';
        import { getAnalytics } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-analytics.js';

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyA5KRYguUg2u4zHS_r2DbI6S0WwJ11oeEk",
            authDomain: "uranus-db22f.firebaseapp.com",
            databaseURL: "https://uranus-db22f-default-rtdb.firebaseio.com/",
            projectId: "uranus-db22f",
            storageBucket: "uranus-db22f.firebasestorage.app",
            messagingSenderId: "979661079223",
            appId: "1:979661079223:web:2aa18fa4047aefdee44332",
            measurementId: "G-6XPFCFFC8M"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        const analytics = getAnalytics(app);

        // Make Firebase available globally
        window.firebaseApp = app;
        window.firebaseDatabase = database;
        window.firebaseAnalytics = analytics;
        window.firebaseRef = ref;
        window.firebaseSet = set;
        window.firebaseGet = get;
        window.firebaseOnValue = onValue;
        window.firebaseIncrement = increment;
    </script>
    
    <div id="scene-container"></div>
    
    <div class="hud">
        <div id="fart-counter">üí® 0</div>
    </div>
    
    <div class="country-info">
        <div id="user-location">üåç Detecting location...</div>
        </div>
        
    <div class="leaderboard collapsed" id="leaderboard">
        <div class="leaderboard-preview">
            <div class="leaderboard-preview-left">
                <span>#1 Leading:</span>
            </div>
            <div class="leaderboard-preview-right">
                <div class="top-country" id="top-country-preview">
                    <span class="loading-state">Loading...</span>
            </div>
        </div>
        </div>
        <div class="leaderboard-header">
            <h3 id="leaderboard-title">üí® Global Fartboard</h3>
        </div>
        <div class="leaderboard-content">
            <div id="leaderboard-table-container">
                <div class="loading-state">Loading countries...</div>
            </div>
        </div>
        <button class="leaderboard-toggle" id="leaderboardToggle">‚ñº</button>
    </div>
    
    <button class="mute-btn" id="muteBtn">üîä</button>
    
    <div class="social-links">
        <a href="https://twitter.com/intent/tweet?text=I%20just%20made%20Uranus%20fart%20in%203D!%20üöÄüí®&url=https://enteruranus.com" target="_blank">üê¶</a>
        <a href="https://t.me/share/url?url=https://enteruranus.com&text=I%20just%20made%20Uranus%20fart%20in%203D!%20üöÄüí®" target="_blank">‚úàÔ∏è</a>
    </div>
    
    <div class="trading-links">
        <a href="https://x.com/Uranus_jup" target="_blank" rel="noopener noreferrer" class="link-item" style="--mobile-icon-size: 40px; --desktop-icon-size: 40px;">
            <img alt="X / Twitter" src="icons/twitter.png">
            <span class="tooltip">X / Twitter</span>
        </a>
        
        <a href="https://x.com/i/communities/1940787479281361171" target="_blank" rel="noopener noreferrer" class="link-item" style="--mobile-icon-size: 40px; --desktop-icon-size: 40px;">
            <img alt="Community" src="icons/community.png">
            <span class="tooltip">Community</span>
        </a>

        <a href="https://dexscreener.com/solana/7cckzmrxbpfhwyzgpqpukl6beywaetsnhwnwe3jenevc" target="_blank" rel="noopener noreferrer" class="link-item" style="--mobile-icon-size: 40px; --desktop-icon-size: 40px;">
            <img alt="DexScreener" src="icons/dexscreener.png">
            <span class="tooltip">DexScreener</span>
        </a>

        <a href="https://jup.ag/tokens/BFgdzMkTPdKKJeTipv2njtDEwhKxkgFueJQfJGt1jups" target="_blank" rel="noopener noreferrer" class="link-item" style="--mobile-icon-size: 40px; --desktop-icon-size: 40px;">
            <img alt="Buy on Jupiter" src="icons/jupiter.png">
            <span class="tooltip">Buy on Jupiter</span>
        </a>

        <a href="https://www.bitmart.com/trade/en-US?symbol=URANUS_USDT&type=spot" target="_blank" rel="noopener noreferrer" class="link-item" style="--mobile-icon-size: 40px; --desktop-icon-size: 40px;">
            <img alt="Buy on BitMart" src="icons/bitmart.png">
            <span class="tooltip">Buy on BitMart</span>
        </a>

        <a href="https://www.kcex.com/exchange/URANUS_USDT?_from=search" target="_blank" rel="noopener noreferrer" class="link-item" style="--mobile-icon-size: 40px; --desktop-icon-size: 40px;">
            <img alt="Buy on KCEX" src="icons/kcex.png">
            <span class="tooltip">Buy on KCEX</span>
        </a>

        <a href="https://www.lbank.com/nl/trade/uranus_usdt" target="_blank" rel="noopener noreferrer" class="link-item" style="--mobile-icon-size: 40px; --desktop-icon-size: 40px;">
            <img alt="Buy on LBank" src="icons/lbank.png">
            <span class="tooltip">Buy on LBank</span>
        </a>

        <a href="https://solscan.io/token/BFgdzMkTPdKKJeTipv2njtDEwhKxkgFueJQfJGt1jups" target="_blank" rel="noopener noreferrer" class="link-item" style="--mobile-icon-size: 40px; --desktop-icon-size: 40px;">
            <img alt="Solscan" src="icons/solscan.png">
            <span class="tooltip">Solscan</span>
        </a>

        <button class="link-item ca-button" onclick="copyContractAddress()" style="--mobile-icon-size: 40px; --desktop-icon-size: 40px;">
            CA
            <span class="tooltip">Copy Contract Address</span>
        </button>
    </div>
    
    <div id="copyNotification" class="copy-notification">Contract address copied! üìã</div>

    <script>
        class UranusUniverse {
            constructor() {
                this.fartCount = 0;
                this.isMuted = false;
                this.audioContext = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.uranusPlanet = null;
                this.flyingObjects = [];
                this.particles = [];
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.isInsideUranus = false;
                this.cameraTarget = new THREE.Vector3(0, 0, 0);
                
                // Cat animation properties
                this.catPlanet = null;
                this.catSpriteCanvas = null;
                this.catSpriteCtx = null;
                this.catSpriteTexture = null;
                this.catImageSequence = [];
                this.catCurrentFrame = 0;
                this.catIsAnimating = false;
                this.catImagesLoaded = 0;
                
                // Pumpkid animation properties
                this.pumpkidPlanet = null;
                this.pumpkidSpriteCanvas = null;
                this.pumpkidSpriteCtx = null;
                this.pumpkidSpriteTexture = null;
                this.pumpkidImageSequence = [];
                this.pumpkidCurrentFrame = 0;
                this.pumpkidIsAnimating = false;
                this.pumpkidImagesLoaded = 0;
                
                // Ass animation properties
                this.assPlanet = null;
                this.assSpriteCanvas = null;
                this.assSpriteCtx = null;
                this.assSpriteTexture = null;
                this.assImageSequence = [];
                this.assCurrentFrame = 0;
                this.assIsAnimating = false;
                this.assImagesLoaded = 0;
                
                // Fire animation properties
                this.firePlanet = null;
                this.fireSpriteCanvas = null;
                this.fireSpriteCtx = null;
                this.fireSpriteTexture = null;
                this.fireImageSequence = [];
                this.fireCurrentFrame = 0;
                this.fireIsAnimating = false;
                this.fireImagesLoaded = 0;
                
                // Global leaderboard properties
                this.userCountry = null;
                this.userCountryCode = null;
                this.database = null;
                this.leaderboardData = {};
                
                // Initialize country mapping FIRST
                this.countryNames = this.initCountryData();
                console.log('Country names initialized:', this.countryNames);
                
                this.init();
            }

            initCountryData() {
                // Country code to name and flag mapping
                return {
                    'US': { name: 'United States', flag: 'üá∫üá∏' },
                    'CN': { name: 'China', flag: 'üá®üá≥' },
                    'TH': { name: 'Thailand', flag: 'üáπüá≠' },
                    'HK': { name: 'Hong Kong', flag: 'üá≠üá∞' },
                    'TW': { name: 'Taiwan', flag: 'üáπüáº' },
                    'JP': { name: 'Japan', flag: 'üáØüáµ' },
                    'KR': { name: 'South Korea', flag: 'üá∞üá∑' },
                    'MY': { name: 'Malaysia', flag: 'üá≤üáæ' },
                    'SA': { name: 'Saudi Arabia', flag: 'üá∏üá¶' },
                    'ID': { name: 'Indonesia', flag: 'üáÆüá©' },
                    'FI': { name: 'Finland', flag: 'üá´üáÆ' },
                    'SE': { name: 'Sweden', flag: 'üá∏üá™' },
                    'GB': { name: 'United Kingdom', flag: 'üá¨üáß' },
                    'DE': { name: 'Germany', flag: 'üá©üá™' },
                    'FR': { name: 'France', flag: 'üá´üá∑' },
                    'IT': { name: 'Italy', flag: 'üáÆüáπ' },
                    'ES': { name: 'Spain', flag: 'üá™üá∏' },
                    'BR': { name: 'Brazil', flag: 'üáßüá∑' },
                    'CA': { name: 'Canada', flag: 'üá®üá¶' },
                    'AU': { name: 'Australia', flag: 'üá¶üá∫' },
                    'IN': { name: 'India', flag: 'üáÆüá≥' },
                    'RU': { name: 'Russia', flag: 'üá∑üá∫' },
                    'MX': { name: 'Mexico', flag: 'üá≤üáΩ' },
                    'AR': { name: 'Argentina', flag: 'üá¶üá∑' },
                    'PL': { name: 'Poland', flag: 'üáµüá±' },
                    'NL': { name: 'Netherlands', flag: 'üá≥üá±' },
                    'BE': { name: 'Belgium', flag: 'üáßüá™' },
                    'CH': { name: 'Switzerland', flag: 'üá®üá≠' },
                    'AT': { name: 'Austria', flag: 'üá¶üáπ' },
                    'NO': { name: 'Norway', flag: 'üá≥üá¥' },
                    'DK': { name: 'Denmark', flag: 'üá©üá∞' }
                };
            }

            async init() {
                this.setupAudio();
                this.createScene();
                this.createUranus();
                this.createCat();
                this.createPumpkid();
                this.createAss();
                this.createFire();
                this.createStarfield();
                this.createFlyingObjects();
                this.setupEventListeners();
                this.loadProgress();
                this.animate();
                
                // Initialize global leaderboard system
                await this.initFirebase();
                await this.detectUserLocation();
                this.setupLeaderboardListener();
                
                // Spawn flying objects more frequently
                setInterval(() => this.spawnFlyingObject(), 1000); // Further reduced to 1000ms
                // Also spawn horizontal objects from both directions
                setInterval(() => this.spawnHorizontalObject(), 2500); // Left to right
                setInterval(() => this.spawnHorizontalObjectReverse(), 3000); // Right to left
            }

            async initFirebase() {
                try {
                    // Wait for Firebase to be available
                    await this.waitForFirebase();
                    
                    console.log('Firebase initialized successfully');
                    this.database = window.firebaseDatabase;
                    
                    // Initialize leaderboard data from Firebase
                    await this.loadLeaderboardFromFirebase();
                    
                } catch (error) {
                    console.log('Firebase not available, using localStorage fallback:', error);
                    this.initLocalStorageLeaderboard();
                }
            }

            async waitForFirebase() {
                return new Promise((resolve, reject) => {
                    const checkFirebase = () => {
                        if (window.firebaseDatabase) {
                            resolve();
                        } else {
                            setTimeout(checkFirebase, 100);
                        }
                    };
                    checkFirebase();
                    
                    // Timeout after 5 seconds
                    setTimeout(() => reject(new Error('Firebase timeout')), 5000);
                });
            }

            async loadLeaderboardFromFirebase() {
                try {
                    const leaderboardRef = window.firebaseRef(this.database, 'leaderboard');
                    const snapshot = await window.firebaseGet(leaderboardRef);
                    
                    if (snapshot.exists()) {
                        this.leaderboardData = snapshot.val();
                        console.log('Loaded leaderboard from Firebase:', this.leaderboardData);
                    } else {
                        // Initialize with demo data if no data exists
                        console.log('No Firebase data found, initializing with demo data');
                        await this.initFirebaseWithDemoData();
                    }
                } catch (error) {
                    console.error('Error loading from Firebase:', error);
                    this.initLocalStorageLeaderboard();
                }
            }

            async initFirebaseWithDemoData() {
                const demoData = {
                    'TH': 45000000,
                    'HK': 32000000,
                    'TW': 28000000,
                    'JP': 25000000,
                    'KR': 18000000,
                    'MY': 15000000,
                    'US': 9500000,
                    'ID': 8200000,
                    'FI': 6800000,
                    'SE': 5900000
                };

                try {
                    const leaderboardRef = window.firebaseRef(this.database, 'leaderboard');
                    await window.firebaseSet(leaderboardRef, demoData);
                    this.leaderboardData = demoData;
                    console.log('Initialized Firebase with demo data');
                } catch (error) {
                    console.error('Error initializing Firebase with demo data:', error);
                    this.leaderboardData = demoData;
                }
            }

            initLocalStorageLeaderboard() {
                // Initialize with demo data for development
                const demoData = {
                    'TH': 45000000,
                    'HK': 32000000,
                    'TW': 28000000,
                    'JP': 25000000,
                    'KR': 18000000,
                    'MY': 15000000,
                    'US': 9500000,
                    'ID': 8200000,
                    'FI': 6800000,
                    'SE': 5900000
                };
                
                // Force clear any old cached data
                localStorage.removeItem('globalLeaderboard');
                localStorage.setItem('globalLeaderboard', JSON.stringify(demoData));
                this.leaderboardData = demoData;
                
                // Debug: Verify country mapping is working
                console.log('=== DEBUGGING LEADERBOARD ===');
                console.log('Demo data:', this.leaderboardData);
                console.log('Country names mapping:', this.countryNames);
                
                // Test mapping for TH
                console.log('TH maps to:', this.countryNames['TH']);
            }

            async detectUserLocation() {
                try {
                    // Try multiple IP geolocation services
                    const services = [
                        'https://ipapi.co/json/',
                        'https://ip-api.com/json/',
                        'https://ipinfo.io/json'
                    ];

                    for (const service of services) {
                        try {
                            const response = await fetch(service);
                            const data = await response.json();
                            
                            if (data.country_code || data.countryCode || data.country) {
                                this.userCountryCode = data.country_code || data.countryCode || data.country;
                                this.userCountry = this.countryNames[this.userCountryCode]?.name || this.userCountryCode;
                                
                                const userFlagIcon = `<span class="fi fi-${this.userCountryCode.toLowerCase()}" 
                                                           style="width: 20px; height: 15px; display: inline-block; margin-right: 8px; border-radius: 2px;" 
                                                           title="Flag of ${this.userCountry}"></span>`;
                                document.getElementById('user-location').innerHTML = `${userFlagIcon}${this.userCountry}`;
                                
                                console.log(`Detected location: ${this.userCountry} (${this.userCountryCode})`);
                                break;
                            }
                        } catch (err) {
                            console.log(`Service ${service} failed:`, err);
                        }
                    }
                    
                    if (!this.userCountryCode) {
                        // Fallback to US for demo
                        this.userCountryCode = 'US';
                        this.userCountry = 'United States';
                        const fallbackFlag = `<span class="fi fi-us" 
                                                   style="width: 20px; height: 15px; display: inline-block; margin-right: 8px; border-radius: 2px;" 
                                                   title="Flag of United States"></span>`;
                        document.getElementById('user-location').innerHTML = `${fallbackFlag}United States (Demo)`;
                    }
                    
                } catch (error) {
                    console.log('Location detection failed:', error);
                    this.userCountryCode = 'US';
                    this.userCountry = 'United States';
                    document.getElementById('user-location').innerHTML = `<span style="margin-right: 8px;">üåç</span>Location Unknown`;
                }
            }

            setupLeaderboardListener() {
                if (this.database) {
                    // Use Firebase real-time listener
                    const leaderboardRef = window.firebaseRef(this.database, 'leaderboard');
                    window.firebaseOnValue(leaderboardRef, (snapshot) => {
                        if (snapshot.exists()) {
                            this.leaderboardData = snapshot.val();
                            this.updateLeaderboard();
                            console.log('Real-time update from Firebase:', this.leaderboardData);
                        }
                    });
                } else {
                    // Fallback to polling for localStorage
                    this.updateLeaderboard();
                    setInterval(() => {
                        this.updateLeaderboard();
                    }, 5000);
                }
            }

            updateLeaderboard() {
                const tableContainer = document.getElementById('leaderboard-table-container');
                const topCountryPreview = document.getElementById('top-country-preview');
                const leaderboardTitle = document.getElementById('leaderboard-title');
                
                // Sort countries by fart count
                const sortedCountries = Object.entries(this.leaderboardData)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 10); // Top 10

                if (sortedCountries.length === 0) {
                    tableContainer.innerHTML = '<div class="loading-state">Loading countries...</div>';
                    topCountryPreview.innerHTML = '<span class="loading-state">Loading...</span>';
                    leaderboardTitle.innerHTML = 'üí® Global Fartboard';
                    return;
                }

                // Update leaderboard title with top country
                if (sortedCountries.length > 0) {
                    const [topCountryCode, topCount] = sortedCountries[0];
                    const topCountryInfo = this.countryNames[topCountryCode];
                    const topDisplayName = topCountryInfo?.name || 'Unknown';
                    leaderboardTitle.innerHTML = `üí® ${topDisplayName} touched Uranus the most`;
                }

                // Update top country preview
                if (sortedCountries.length > 0) {
                    const [topCountryCode, topCount] = sortedCountries[0];
                    const topCountryInfo = this.countryNames[topCountryCode];
                    const topDisplayName = topCountryInfo?.name || 'Unknown';
                    const topFlagIcon = `<span class="fi fi-${topCountryCode.toLowerCase()}" 
                                              style="width: 18px; height: 14px; border-radius: 2px;" 
                                              title="Flag of ${topDisplayName}"></span>`;
                    
                    topCountryPreview.innerHTML = `
                        ${topFlagIcon}
                        <span>${topDisplayName}</span>
                        <span style="color: #00ffff;">üí® ${this.formatNumberFull(topCount)}</span>
                    `;
                }

                let html = '<table class="leaderboard-table">';
                
                sortedCountries.forEach(([countryCode, count], index) => {
                    const countryInfo = this.countryNames[countryCode];
                    const isUserCountry = countryCode === this.userCountryCode;
                    const rank = index + 1;
                    
                    let rankClass = 'rank-cell';
                    let rankDisplay = rank;
                    
                    if (rank === 1) {
                        rankClass += ' gold';
                        rankDisplay = 'ü•á';
                    } else if (rank === 2) {
                        rankClass += ' silver';
                        rankDisplay = 'ü•à';
                    } else if (rank === 3) {
                        rankClass += ' bronze';
                        rankDisplay = 'ü•â';
                    }
                    
                    // Ensure we show flag + country name, never country codes
                    const displayName = countryInfo?.name || 'Unknown';
                    
                    // Create flag icon using flag-icons library
                    const flagIcon = `<span class="fi fi-${countryCode.toLowerCase()} country-flag" 
                                           title="Flag of ${displayName}" 
                                           aria-label="Flag of ${displayName}"></span>`;
                    
                    html += `
                        <tr class="leaderboard-row ${isUserCountry ? 'user-country' : ''}">
                            <td class="${rankClass}">${rankDisplay}</td>
                            <td class="leaderboard-cell">
                                <div class="country-cell">
                                    ${flagIcon}
                                    <span class="country-name">${displayName}</span>
                                </div>
                            </td>
                            <td class="leaderboard-cell score-cell">üí® ${this.formatNumberFull(count)}</td>
                        </tr>
                    `;
                });

                html += '</table>';
                tableContainer.innerHTML = html;
            }

            formatNumber(num) {
                if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return num.toString();
            }

            formatNumberFull(num) {
                // Format with commas for full numbers
                return num.toLocaleString();
            }

            incrementGlobalCount() {
                if (this.userCountryCode) {
                    // Add to country's count
                    this.leaderboardData[this.userCountryCode] = 
                        (this.leaderboardData[this.userCountryCode] || 0) + 1;
                    
                    // Save to localStorage (in real app, this would sync to Firebase)
                    localStorage.setItem('globalLeaderboard', JSON.stringify(this.leaderboardData));
                    
                    // Update leaderboard display
                    this.updateLeaderboard();
                    
                    console.log(`Added fart for ${this.userCountry}: ${this.leaderboardData[this.userCountryCode]}`);
                }
            }

            setupAudio() {
                if ('AudioContext' in window || 'webkitAudioContext' in window) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Load the real fart sound
                this.fartAudio = new Audio('sound_effects/PROUD_FART.mp3');
                this.fartAudio.preload = 'auto';
                
                // Load the slap sound for cat
                this.slapAudio = new Audio('sound_effects/11L-Loud_slap_sound-1754727690182.mp3');
                this.slapAudio.preload = 'auto';
                
                // Load the ass burning sound
                this.assBurningAudio = new Audio('sound_effects/Assburning.mp3');
                this.assBurningAudio.preload = 'auto';
                
                // Load the fire/asteroid burning sound
                this.fireBurningAudio = new Audio('sound_effects/11L-Asteroid_burning,_fl-1754880555898.mp3');
                this.fireBurningAudio.preload = 'auto';
                
                // Load explosion sound for flying objects (you can replace this path)
                this.explosionAudio = new Audio('sound_effects/explosion.mp3');
                this.explosionAudio.preload = 'auto';
            }

            createUranus() {
                // Create a 2D plane for sprite animation instead of 3D sphere
                const geometry = new THREE.PlaneGeometry(10, 10);
                
                // Create high-resolution canvas for sprite animation with transparency
                this.spriteCanvas = document.createElement('canvas');
                this.spriteCanvas.width = 1024;
                this.spriteCanvas.height = 1024;
                this.spriteCtx = this.spriteCanvas.getContext('2d');
                
                // Enable high-quality image rendering
                this.spriteCtx.imageSmoothingEnabled = true;
                this.spriteCtx.imageSmoothingQuality = 'high';
                
                // Enable transparency
                this.spriteCtx.globalCompositeOperation = 'source-over';
                
                // Animation properties for your 4 frames
                this.currentFrame = 0;
                this.totalFrames = 4;
                this.isAnimating = false;
                this.animationSpeed = 100; // 100ms per frame = 400ms total (50% faster)
                
                // Load your custom image sequence
                this.loadCustomImageSequence();
                
                // Create texture from canvas with transparency
                this.spriteTexture = new THREE.CanvasTexture(this.spriteCanvas);
                this.spriteTexture.needsUpdate = true;
                // Remove flipY to keep original orientation
                
                const material = new THREE.MeshBasicMaterial({ 
                    map: this.spriteTexture,
                    transparent: true,
                    alphaTest: 0.1,
                    side: THREE.DoubleSide
                });
                
                this.uranusPlanet = new THREE.Mesh(geometry, material);
                this.uranusPlanet.userData = { type: 'uranus' };
                this.uranusPlanet.position.set(0, 0, 0);
                this.scene.add(this.uranusPlanet);
                
                console.log('Created static Uranus plane with transparency');
            }
            
            // Load your custom 4-frame sequence
            loadCustomImageSequence() {
                const imagePaths = [
                    'Assets/First.png',     // Frame 0 - Normal planet (capital F)
                    'Assets/second.png',    // Frame 1 - Animation frame 1 (lowercase)
                    'Assets/third.png',     // Frame 2 - Animation frame 2 (lowercase)
                    'Assets/fourth.png'     // Frame 3 - Animation frame 3 (lowercase)
                ];
                
                console.log('Loading planet image sequence:', imagePaths);
                
                this.imageSequence = [];
                this.totalFrames = imagePaths.length;
                this.currentFrame = 0;
                this.isAnimating = false;
                this.imagesLoaded = 0;
                
                // Load all images with better error handling
                imagePaths.forEach((path, index) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        console.log(`‚úì Loaded planet image ${index + 1}/${imagePaths.length}: ${path} (${img.naturalWidth}x${img.naturalHeight})`);
                        this.imagesLoaded++;
                        
                        if (this.imagesLoaded === imagePaths.length) {
                            console.log('üéâ All planet images loaded! Showing First.png...');
                            console.log('Image sequence status:', this.imageSequence.map((img, i) => `Frame ${i}: ${img.complete ? '‚úÖ' : '‚ùå'} ${img.naturalWidth}x${img.naturalHeight}`));
                            // Show the first frame (normal planet)
                            setTimeout(() => this.drawImageFrame(0), 100);
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error(`‚ùå Failed to load planet image: ${path}`, error);
                        // Try to continue with other images
                        this.imagesLoaded++;
                    };
                    
                    this.imageSequence[index] = img;
                    img.src = path;
                });
            }
            
            // Draw frame from image sequence with proper transparency
            drawImageFrame(frameIndex) {
                if (!this.imageSequence || !this.imageSequence[frameIndex]) {
                    console.error(`‚ùå Planet image not ready: frameIndex=${frameIndex}`);
                    return;
                }
                
                const img = this.imageSequence[frameIndex];
                if (!img.complete || img.naturalWidth === 0) {
                    console.error(`‚ùå Planet image not fully loaded: frameIndex=${frameIndex}, complete=${img.complete}, naturalWidth=${img.naturalWidth}`);
                    return;
                }
                
                // Clear canvas completely with transparency
                this.spriteCtx.clearRect(0, 0, this.spriteCanvas.width, this.spriteCanvas.height);
                
                // Save context state
                this.spriteCtx.save();
                
                try {
                    // Draw the planet image centered with proper transparency
                    this.spriteCtx.globalCompositeOperation = 'source-over';
                    this.spriteCtx.drawImage(
                        img,
                        0, 0, img.naturalWidth, img.naturalHeight, // Source
                        0, 0, this.spriteCanvas.width, this.spriteCanvas.height // Destination
                    );
                    
                    console.log(`‚úÖ Successfully drew planet frame: ${frameIndex} (${img.src.split('/').pop()}) - ${img.naturalWidth}x${img.naturalHeight}`);
                } catch (error) {
                    console.error(`‚ùå Error drawing frame ${frameIndex}:`, error);
                }
                
                // Restore context state
                this.spriteCtx.restore();
                
                // Force texture update
                this.spriteTexture.needsUpdate = true;
            }
            
            // Play the click animation: First.png ‚Üí second.png ‚Üí third.png ‚Üí fourth.png ‚Üí First.png
            playClickAnimation() {
                if (this.isAnimating) {
                    console.log('üö´ Animation already in progress, skipping');
                    return; // Don't interrupt current animation
                }
                
                if (this.imagesLoaded < 4) {
                    console.log('üö´ Images not fully loaded yet, skipping animation');
                    return;
                }
                
                console.log('üé¨ Starting planet click animation...');
                console.log('Current animation state:', {
                    isAnimating: this.isAnimating,
                    imagesLoaded: this.imagesLoaded,
                    totalFrames: this.totalFrames,
                    imageSequenceLength: this.imageSequence?.length
                });
                this.isAnimating = true;
                
                // Animation sequence: 1 ‚Üí 2 ‚Üí 3 ‚Üí back to 0 (1 second total)
                const sequence = [1, 2, 3, 0];
                let sequenceIndex = 0;
                
                const animateFrame = () => {
                    if (sequenceIndex < sequence.length) {
                        const frameIndex = sequence[sequenceIndex];
                        console.log(`üéûÔ∏è Animating to frame ${frameIndex} (${this.imageSequence[frameIndex]?.src})`);
                        this.drawImageFrame(frameIndex);
                        sequenceIndex++;
                        
                        // Continue animation after delay
                        setTimeout(animateFrame, this.animationSpeed);
                    } else {
                        // Animation complete
                        this.isAnimating = false;
                        console.log('‚úÖ Planet click animation complete - back to frame 0');
                    }
                };
                
                // Start the animation immediately
                animateFrame();
            }

            createCat() {
                // Create a 2D plane for cat sprite animation
                const catGeometry = new THREE.PlaneGeometry(7.5, 7.5); // Made smaller by 0.5
                
                // Create high-resolution canvas for cat sprite animation with transparency
                this.catSpriteCanvas = document.createElement('canvas');
                this.catSpriteCanvas.width = 2048;
                this.catSpriteCanvas.height = 2048;
                this.catSpriteCtx = this.catSpriteCanvas.getContext('2d');
                
                // Enable high-quality image rendering
                this.catSpriteCtx.imageSmoothingEnabled = true;
                this.catSpriteCtx.imageSmoothingQuality = 'high';
                
                // Enable transparency
                this.catSpriteCtx.globalCompositeOperation = 'source-over';
                
                // Cat animation properties for 2 frames
                this.catCurrentFrame = 0;
                this.catTotalFrames = 2;
                this.catIsAnimating = false;
                this.catAnimationSpeed = 100; // Same as planet speed
                
                // Load cat image sequence
                this.loadCatImageSequence();
                
                // Create texture from canvas with transparency
                this.catSpriteTexture = new THREE.CanvasTexture(this.catSpriteCanvas);
                this.catSpriteTexture.needsUpdate = true;
                
                const catMaterial = new THREE.MeshBasicMaterial({ 
                    map: this.catSpriteTexture,
                    transparent: true,
                    alphaTest: 0.1,
                    side: THREE.DoubleSide
                });
                
                this.catPlanet = new THREE.Mesh(catGeometry, catMaterial);
                this.catPlanet.userData = { type: 'cat' };
                // Position to the left of the planet and further away
                this.catPlanet.position.set(-20, -7.7, -5);
                this.scene.add(this.catPlanet);
                
                console.log('Created cat plane with transparency at position (-15, 0, -5)');
            }
            
            // Load cat 2-frame sequence
            loadCatImageSequence() {
                const catImagePaths = [
                    'Assets/Firstcat.png',     // Frame 0 - Normal cat
                    'Assets/secondcat.png'     // Frame 1 - Animation frame
                ];
                
                console.log('Loading cat image sequence:', catImagePaths);
                
                this.catImageSequence = [];
                this.catTotalFrames = catImagePaths.length;
                this.catCurrentFrame = 0;
                this.catIsAnimating = false;
                this.catImagesLoaded = 0;
                
                // Load all cat images with error handling
                catImagePaths.forEach((path, index) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        console.log(`‚úì Loaded cat image ${index + 1}/${catImagePaths.length}: ${path} (${img.naturalWidth}x${img.naturalHeight})`);
                        this.catImagesLoaded++;
                        
                        if (this.catImagesLoaded === catImagePaths.length) {
                            console.log('üéâ All cat images loaded! Showing Firstcat.png...');
                            console.log('Cat image sequence status:', this.catImageSequence.map((img, i) => `Frame ${i}: ${img.complete ? '‚úÖ' : '‚ùå'} ${img.naturalWidth}x${img.naturalHeight}`));
                            // Show the first frame (normal cat)
                            setTimeout(() => this.drawCatImageFrame(0), 100);
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error(`‚ùå Failed to load cat image: ${path}`, error);
                        this.catImagesLoaded++;
                    };
                    
                    this.catImageSequence[index] = img;
                    img.src = path;
                });
            }
            
            // Draw cat frame from image sequence with proper transparency
            drawCatImageFrame(frameIndex) {
                if (!this.catImageSequence || !this.catImageSequence[frameIndex]) {
                    console.error(`‚ùå Cat image not ready: frameIndex=${frameIndex}`);
                    return;
                }
                
                const img = this.catImageSequence[frameIndex];
                if (!img.complete || img.naturalWidth === 0) {
                    console.error(`‚ùå Cat image not fully loaded: frameIndex=${frameIndex}, complete=${img.complete}, naturalWidth=${img.naturalWidth}`);
                    return;
                }
                
                // Clear canvas completely with transparency
                this.catSpriteCtx.clearRect(0, 0, this.catSpriteCanvas.width, this.catSpriteCanvas.height);
                
                // Save context state
                this.catSpriteCtx.save();
                
                try {
                    // Draw the cat image centered with proper transparency
                    this.catSpriteCtx.globalCompositeOperation = 'source-over';
                    this.catSpriteCtx.drawImage(
                        img,
                        0, 0, img.naturalWidth, img.naturalHeight, // Source
                        0, 0, this.catSpriteCanvas.width, this.catSpriteCanvas.height // Destination
                    );
                    
                    console.log(`‚úÖ Successfully drew cat frame: ${frameIndex} (${img.src.split('/').pop()}) - ${img.naturalWidth}x${img.naturalHeight}`);
                } catch (error) {
                    console.error(`‚ùå Error drawing cat frame ${frameIndex}:`, error);
                }
                
                // Restore context state
                this.catSpriteCtx.restore();
                
                // Force texture update
                this.catSpriteTexture.needsUpdate = true;
            }
            
            // Play the cat click animation: Firstcat.png ‚Üí secondcat.png ‚Üí Firstcat.png
            playCatClickAnimation() {
                if (this.catIsAnimating) {
                    console.log('üö´ Cat animation already in progress, skipping');
                    return;
                }
                
                if (this.catImagesLoaded < 2) {
                    console.log('üö´ Cat images not fully loaded yet, skipping animation');
                    return;
                }
                
                console.log('üé¨ Starting cat click animation...');
                this.catIsAnimating = true;
                
                // Animation sequence: 1 ‚Üí 0 (2 frames total, 300ms)
                const sequence = [1, 0];
                let sequenceIndex = 0;
                
                const animateCatFrame = () => {
                    if (sequenceIndex < sequence.length) {
                        const frameIndex = sequence[sequenceIndex];
                        console.log(`üéûÔ∏è Animating cat to frame ${frameIndex} (${this.catImageSequence[frameIndex]?.src})`);
                        this.drawCatImageFrame(frameIndex);
                        sequenceIndex++;
                        
                        // Continue animation after delay
                        setTimeout(animateCatFrame, this.catAnimationSpeed);
                    } else {
                        // Animation complete
                        this.catIsAnimating = false;
                        console.log('‚úÖ Cat click animation complete - back to frame 0');
                    }
                };
                
                // Start the animation immediately
                animateCatFrame();
            }

            createPumpkid() {
                // Create a 2D plane for pumpkid sprite animation
                const pumpkidGeometry = new THREE.PlaneGeometry(7.5, 7.5); // Made smaller by 0.5
                
                // Create high-resolution canvas for pumpkid sprite animation with transparency
                this.pumpkidSpriteCanvas = document.createElement('canvas');
                this.pumpkidSpriteCanvas.width = 2048;
                this.pumpkidSpriteCanvas.height = 2048;
                this.pumpkidSpriteCtx = this.pumpkidSpriteCanvas.getContext('2d');
                
                // Enable high-quality image rendering
                this.pumpkidSpriteCtx.imageSmoothingEnabled = true;
                this.pumpkidSpriteCtx.imageSmoothingQuality = 'high';
                
                // Enable transparency
                this.pumpkidSpriteCtx.globalCompositeOperation = 'source-over';
                
                // Pumpkid animation properties for 2 frames
                this.pumpkidCurrentFrame = 0;
                this.pumpkidTotalFrames = 2;
                this.pumpkidIsAnimating = false;
                this.pumpkidAnimationSpeed = 100; // Same as planet speed
                
                // Load pumpkid image sequence
                this.loadPumpkidImageSequence();
                
                // Create texture from canvas with transparency
                this.pumpkidSpriteTexture = new THREE.CanvasTexture(this.pumpkidSpriteCanvas);
                this.pumpkidSpriteTexture.needsUpdate = true;
                
                const pumpkidMaterial = new THREE.MeshBasicMaterial({ 
                    map: this.pumpkidSpriteTexture,
                    transparent: true,
                    alphaTest: 0.1,
                    side: THREE.DoubleSide
                });
                
                this.pumpkidPlanet = new THREE.Mesh(pumpkidGeometry, pumpkidMaterial);
                this.pumpkidPlanet.userData = { type: 'pumpkid' };
                // Position to the right of the cat
                this.pumpkidPlanet.position.set(-16.3, -10.1, -6);
                this.scene.add(this.pumpkidPlanet);
                
                console.log('Created pumpkid plane with transparency at position (-7, 0, -5)');
            }
            
            // Load pumpkid 2-frame sequence
            loadPumpkidImageSequence() {
                const pumpkidImagePaths = [
                    'Assets/firstpumpkid.png',     // Frame 0 - Normal pumpkid
                    'Assets/secondpumpkid.png'     // Frame 1 - Animation frame
                ];
                
                console.log('Loading pumpkid image sequence:', pumpkidImagePaths);
                
                this.pumpkidImageSequence = [];
                this.pumpkidTotalFrames = pumpkidImagePaths.length;
                this.pumpkidCurrentFrame = 0;
                this.pumpkidIsAnimating = false;
                this.pumpkidImagesLoaded = 0;
                
                // Load all pumpkid images with error handling
                pumpkidImagePaths.forEach((path, index) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        console.log(`‚úì Loaded pumpkid image ${index + 1}/${pumpkidImagePaths.length}: ${path} (${img.naturalWidth}x${img.naturalHeight})`);
                        this.pumpkidImagesLoaded++;
                        
                        if (this.pumpkidImagesLoaded === pumpkidImagePaths.length) {
                            console.log('üéâ All pumpkid images loaded! Showing firstpumpkid.png...');
                            console.log('Pumpkid image sequence status:', this.pumpkidImageSequence.map((img, i) => `Frame ${i}: ${img.complete ? '‚úÖ' : '‚ùå'} ${img.naturalWidth}x${img.naturalHeight}`));
                            // Show the first frame (normal pumpkid)
                            setTimeout(() => this.drawPumpkidImageFrame(0), 100);
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error(`‚ùå Failed to load pumpkid image: ${path}`, error);
                        this.pumpkidImagesLoaded++;
                    };
                    
                    this.pumpkidImageSequence[index] = img;
                    img.src = path;
                });
            }
            
            // Draw pumpkid frame from image sequence with proper transparency
            drawPumpkidImageFrame(frameIndex) {
                if (!this.pumpkidImageSequence || !this.pumpkidImageSequence[frameIndex]) {
                    console.error(`‚ùå Pumpkid image not ready: frameIndex=${frameIndex}`);
                    return;
                }
                
                const img = this.pumpkidImageSequence[frameIndex];
                if (!img.complete || img.naturalWidth === 0) {
                    console.error(`‚ùå Pumpkid image not fully loaded: frameIndex=${frameIndex}, complete=${img.complete}, naturalWidth=${img.naturalWidth}`);
                    return;
                }
                
                // Clear canvas completely with transparency
                this.pumpkidSpriteCtx.clearRect(0, 0, this.pumpkidSpriteCanvas.width, this.pumpkidSpriteCanvas.height);
                
                // Save context state
                this.pumpkidSpriteCtx.save();
                
                try {
                    // Draw the pumpkid image centered with proper transparency
                    this.pumpkidSpriteCtx.globalCompositeOperation = 'source-over';
                    this.pumpkidSpriteCtx.drawImage(
                        img,
                        0, 0, img.naturalWidth, img.naturalHeight, // Source
                        0, 0, this.pumpkidSpriteCanvas.width, this.pumpkidSpriteCanvas.height // Destination
                    );
                    
                    console.log(`‚úÖ Successfully drew pumpkid frame: ${frameIndex} (${img.src.split('/').pop()}) - ${img.naturalWidth}x${img.naturalHeight}`);
                } catch (error) {
                    console.error(`‚ùå Error drawing pumpkid frame ${frameIndex}:`, error);
                }
                
                // Restore context state
                this.pumpkidSpriteCtx.restore();
                
                // Force texture update
                this.pumpkidSpriteTexture.needsUpdate = true;
            }
            
            // Play the pumpkid click animation: firstpumpkid.png ‚Üí secondpumpkid.png ‚Üí firstpumpkid.png
            playPumpkidClickAnimation() {
                if (this.pumpkidIsAnimating) {
                    console.log('üö´ Pumpkid animation already in progress, skipping');
                    return;
                }
                
                if (this.pumpkidImagesLoaded < 2) {
                    console.log('üö´ Pumpkid images not fully loaded yet, skipping animation');
                    return;
                }
                
                console.log('üé¨ Starting pumpkid click animation...');
                this.pumpkidIsAnimating = true;
                
                // Animation sequence: 1 ‚Üí 0 (2 frames total, 300ms)
                const sequence = [1, 0];
                let sequenceIndex = 0;
                
                const animatePumpkidFrame = () => {
                    if (sequenceIndex < sequence.length) {
                        const frameIndex = sequence[sequenceIndex];
                        console.log(`üéûÔ∏è Animating pumpkid to frame ${frameIndex} (${this.pumpkidImageSequence[frameIndex]?.src})`);
                        this.drawPumpkidImageFrame(frameIndex);
                        sequenceIndex++;
                        
                        // Continue animation after delay
                        setTimeout(animatePumpkidFrame, this.pumpkidAnimationSpeed);
                    } else {
                        // Animation complete
                        this.pumpkidIsAnimating = false;
                        console.log('‚úÖ Pumpkid click animation complete - back to frame 0');
                    }
                };
                
                // Start the animation immediately
                animatePumpkidFrame();
            }

            createAss() {
                // Create a 2D plane for ass sprite animation
                const assGeometry = new THREE.PlaneGeometry(8.5, 8.5); // Made bigger by 1
                
                // Create high-resolution canvas for ass sprite animation with transparency
                this.assSpriteCanvas = document.createElement('canvas');
                this.assSpriteCanvas.width = 2048;
                this.assSpriteCanvas.height = 2048;
                this.assSpriteCtx = this.assSpriteCanvas.getContext('2d');
                
                // Enable high-quality image rendering
                this.assSpriteCtx.imageSmoothingEnabled = true;
                this.assSpriteCtx.imageSmoothingQuality = 'high';
                
                // Enable transparency
                this.assSpriteCtx.globalCompositeOperation = 'source-over';
                
                // Ass animation properties for 5 frames
                this.assCurrentFrame = 0;
                this.assTotalFrames = 5;
                this.assIsAnimating = false;
                this.assAnimationSpeed = 100; // Same as planet speed
                
                // Load ass image sequence
                this.loadAssImageSequence();
                
                // Create texture from canvas with transparency
                this.assSpriteTexture = new THREE.CanvasTexture(this.assSpriteCanvas);
                this.assSpriteTexture.needsUpdate = true;
                
                const assMaterial = new THREE.MeshBasicMaterial({ 
                    map: this.assSpriteTexture,
                    transparent: true,
                    alphaTest: 0.1,
                    side: THREE.DoubleSide
                });
                
                this.assPlanet = new THREE.Mesh(assGeometry, assMaterial);
                this.assPlanet.userData = { type: 'ass' };
                // Position on the right side, lower
                this.assPlanet.position.set(-9, 6, -3);
                // Flip horizontally to face right
                this.assPlanet.scale.x = -1;
                this.scene.add(this.assPlanet);
                
                console.log('Created ass plane with transparency at position (15, -3, -5)');
            }
            
            // Load ass 5-frame sequence
            loadAssImageSequence() {
                const assImagePaths = [
                    'Assets/Ass1.png',     // Frame 0
                    'Assets/Ass2.png',     // Frame 1
                    'Assets/Ass3.png',     // Frame 2
                    'Assets/Ass4.png',     // Frame 3
                    'Assets/Ass5.png'      // Frame 4
                ];
                
                console.log('Loading ass image sequence:', assImagePaths);
                
                this.assImageSequence = [];
                this.assTotalFrames = assImagePaths.length;
                this.assCurrentFrame = 0;
                this.assIsAnimating = false;
                this.assImagesLoaded = 0;
                
                // Load all ass images with error handling
                assImagePaths.forEach((path, index) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        console.log(`‚úì Loaded ass image ${index + 1}/${assImagePaths.length}: ${path} (${img.naturalWidth}x${img.naturalHeight})`);
                        this.assImagesLoaded++;
                        
                        if (this.assImagesLoaded === assImagePaths.length) {
                            console.log('üéâ All ass images loaded! Showing Ass1.png...');
                            // Show the first frame (normal ass)
                            setTimeout(() => this.drawAssImageFrame(0), 100);
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error(`‚ùå Failed to load ass image: ${path}`, error);
                        this.assImagesLoaded++;
                    };
                    
                    this.assImageSequence[index] = img;
                    img.src = path;
                });
            }
            
            // Draw ass frame from image sequence with proper transparency
            drawAssImageFrame(frameIndex) {
                if (!this.assImageSequence || !this.assImageSequence[frameIndex]) {
                    console.error(`‚ùå Ass image not ready: frameIndex=${frameIndex}`);
                    return;
                }
                
                const img = this.assImageSequence[frameIndex];
                if (!img.complete || img.naturalWidth === 0) {
                    console.error(`‚ùå Ass image not fully loaded: frameIndex=${frameIndex}`);
                    return;
                }
                
                // Clear canvas completely with transparency
                this.assSpriteCtx.clearRect(0, 0, this.assSpriteCanvas.width, this.assSpriteCanvas.height);
                
                // Save context state
                this.assSpriteCtx.save();
                
                try {
                    // Draw the ass image centered with proper transparency
                    this.assSpriteCtx.globalCompositeOperation = 'source-over';
                    this.assSpriteCtx.drawImage(
                        img,
                        0, 0, img.naturalWidth, img.naturalHeight, // Source
                        0, 0, this.assSpriteCanvas.width, this.assSpriteCanvas.height // Destination
                    );
                    
                    console.log(`‚úÖ Successfully drew ass frame: ${frameIndex} (${img.src.split('/').pop()})`);
                } catch (error) {
                    console.error(`‚ùå Error drawing ass frame ${frameIndex}:`, error);
                }
                
                // Restore context state
                this.assSpriteCtx.restore();
                
                // Force texture update
                this.assSpriteTexture.needsUpdate = true;
            }
            
            // Play the ass animation: Ass1 ‚Üí Ass2 ‚Üí Ass3 ‚Üí Ass4 ‚Üí Ass5 ‚Üí Ass1
            playAssAnimation() {
                if (this.assIsAnimating) {
                    console.log('üö´ Ass animation already in progress, skipping');
                    return;
                }
                
                if (this.assImagesLoaded < 5) {
                    console.log('üö´ Ass images not fully loaded yet, skipping animation');
                    return;
                }
                
                console.log('üé¨ Starting ass animation...');
                this.assIsAnimating = true;
                
                // Animation sequence: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 0 (5 frames total)
                const sequence = [1, 2, 3, 4, 0];
                let sequenceIndex = 0;
                
                const animateAssFrame = () => {
                    if (sequenceIndex < sequence.length) {
                        const frameIndex = sequence[sequenceIndex];
                        console.log(`üéûÔ∏è Animating ass to frame ${frameIndex}`);
                        this.drawAssImageFrame(frameIndex);
                        sequenceIndex++;
                        
                        // Continue animation after delay
                        setTimeout(animateAssFrame, this.assAnimationSpeed);
                    } else {
                        // Animation complete
                        this.assIsAnimating = false;
                        console.log('‚úÖ Ass animation complete - back to frame 0');
                    }
                };
                
                // Start the animation immediately
                animateAssFrame();
            }

            createFire() {
                // Create a 2D plane for fire sprite animation
                const fireGeometry = new THREE.PlaneGeometry(6.5, 6.5); // Made smaller by 1
                
                // Create high-resolution canvas for fire sprite animation with transparency
                this.fireSpriteCanvas = document.createElement('canvas');
                this.fireSpriteCanvas.width = 2048;
                this.fireSpriteCanvas.height = 2048;
                this.fireSpriteCtx = this.fireSpriteCanvas.getContext('2d');
                
                // Enable high-quality image rendering
                this.fireSpriteCtx.imageSmoothingEnabled = true;
                this.fireSpriteCtx.imageSmoothingQuality = 'high';
                
                // Enable transparency
                this.fireSpriteCtx.globalCompositeOperation = 'source-over';
                
                // Fire animation properties for 4 frames
                this.fireCurrentFrame = 0;
                this.fireTotalFrames = 4;
                this.fireIsAnimating = false;
                this.fireAnimationSpeed = 100; // Same as planet speed
                
                // Load fire image sequence
                this.loadFireImageSequence();
                
                // Create texture from canvas with transparency
                this.fireSpriteTexture = new THREE.CanvasTexture(this.fireSpriteCanvas);
                this.fireSpriteTexture.needsUpdate = true;
                
                const fireMaterial = new THREE.MeshBasicMaterial({ 
                    map: this.fireSpriteTexture,
                    transparent: true,
                    alphaTest: 0.1,
                    side: THREE.DoubleSide
                });
                
                this.firePlanet = new THREE.Mesh(fireGeometry, fireMaterial);
                this.firePlanet.userData = { type: 'fire' };
                // Position on the right side, higher
                this.firePlanet.position.set(11, 7, -6.5);
                this.scene.add(this.firePlanet);
                
                console.log('Created fire plane with transparency at position (15, 3, -5)');
            }
            
            // Load fire 4-frame sequence
            loadFireImageSequence() {
                const fireImagePaths = [
                    'Assets/fire1.png',     // Frame 0
                    'Assets/fire2.png',     // Frame 1
                    'Assets/fire3.png',     // Frame 2
                    'Assets/fire4.png'      // Frame 3
                ];
                
                console.log('Loading fire image sequence:', fireImagePaths);
                
                this.fireImageSequence = [];
                this.fireTotalFrames = fireImagePaths.length;
                this.fireCurrentFrame = 0;
                this.fireIsAnimating = false;
                this.fireImagesLoaded = 0;
                
                // Load all fire images with error handling
                fireImagePaths.forEach((path, index) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        console.log(`‚úì Loaded fire image ${index + 1}/${fireImagePaths.length}: ${path} (${img.naturalWidth}x${img.naturalHeight})`);
                        this.fireImagesLoaded++;
                        
                        if (this.fireImagesLoaded === fireImagePaths.length) {
                            console.log('üéâ All fire images loaded! Showing fire1.png...');
                            // Show the first frame (normal fire)
                            setTimeout(() => this.drawFireImageFrame(0), 100);
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error(`‚ùå Failed to load fire image: ${path}`, error);
                        this.fireImagesLoaded++;
                    };
                    
                    this.fireImageSequence[index] = img;
                    img.src = path;
                });
            }
            
            // Draw fire frame from image sequence with proper transparency
            drawFireImageFrame(frameIndex) {
                if (!this.fireImageSequence || !this.fireImageSequence[frameIndex]) {
                    console.error(`‚ùå Fire image not ready: frameIndex=${frameIndex}`);
                    return;
                }
                
                const img = this.fireImageSequence[frameIndex];
                if (!img.complete || img.naturalWidth === 0) {
                    console.error(`‚ùå Fire image not fully loaded: frameIndex=${frameIndex}`);
                    return;
                }
                
                // Clear canvas completely with transparency
                this.fireSpriteCtx.clearRect(0, 0, this.fireSpriteCanvas.width, this.fireSpriteCanvas.height);
                
                // Save context state
                this.fireSpriteCtx.save();
                
                try {
                    // Draw the fire image centered with proper transparency
                    this.fireSpriteCtx.globalCompositeOperation = 'source-over';
                    this.fireSpriteCtx.drawImage(
                        img,
                        0, 0, img.naturalWidth, img.naturalHeight, // Source
                        0, 0, this.fireSpriteCanvas.width, this.fireSpriteCanvas.height // Destination
                    );
                    
                    console.log(`‚úÖ Successfully drew fire frame: ${frameIndex} (${img.src.split('/').pop()})`);
                } catch (error) {
                    console.error(`‚ùå Error drawing fire frame ${frameIndex}:`, error);
                }
                
                // Restore context state
                this.fireSpriteCtx.restore();
                
                // Force texture update
                this.fireSpriteTexture.needsUpdate = true;
            }
            
            // Play the fire animation: fire1 ‚Üí fire2 ‚Üí fire3 ‚Üí fire4 ‚Üí fire1
            playFireAnimation() {
                if (this.fireIsAnimating) {
                    console.log('üö´ Fire animation already in progress, skipping');
                    return;
                }
                
                if (this.fireImagesLoaded < 4) {
                    console.log('üö´ Fire images not fully loaded yet, skipping animation');
                    return;
                }
                
                console.log('üé¨ Starting fire animation...');
                this.fireIsAnimating = true;
                
                // Animation sequence: 1 ‚Üí 2 ‚Üí 3 ‚Üí 0 (4 frames total)
                const sequence = [1, 2, 3, 0];
                let sequenceIndex = 0;
                
                const animateFireFrame = () => {
                    if (sequenceIndex < sequence.length) {
                        const frameIndex = sequence[sequenceIndex];
                        console.log(`üéûÔ∏è Animating fire to frame ${frameIndex}`);
                        this.drawFireImageFrame(frameIndex);
                        sequenceIndex++;
                        
                        // Continue animation after delay
                        setTimeout(animateFireFrame, this.fireAnimationSpeed);
                    } else {
                        // Animation complete
                        this.fireIsAnimating = false;
                        console.log('‚úÖ Fire animation complete - back to frame 0');
                    }
                };
                
                // Start the animation immediately
                animateFireFrame();
            }

            createScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                this.camera.position.set(0, 0, 10);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000011, 1);
                document.getElementById('scene-container').appendChild(this.renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                this.scene.add(directionalLight);
            }

            createStarfield() {
                const starGeometry = new THREE.BufferGeometry();
                const starVertices = [];
                const starColors = [];
                
                for (let i = 0; i < 10000; i++) {
                    const x = (Math.random() - 0.5) * 2000;
                    const y = (Math.random() - 0.5) * 2000;
                    const z = (Math.random() - 0.5) * 2000;
                    starVertices.push(x, y, z);
                    
                    // Random star colors
                    const color = new THREE.Color();
                    color.setHSL(Math.random(), 0.5, Math.random() * 0.5 + 0.5);
                    starColors.push(color.r, color.g, color.b);
                }
                
                starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
                starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
                
                const starMaterial = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true
                });
                
                const stars = new THREE.Points(starGeometry, starMaterial);
                stars.userData = { type: 'starfield', nonInteractive: true }; // Mark as non-clickable
                this.scene.add(stars);
            }

            createFlyingObjects() {
                // Pre-create more flying objects
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => this.spawnFlyingObject(), i * 800);
                }
            }

            spawnFlyingObject() {
                const types = ['rocket', 'ufo', 'asteroid', 'satellite', 'comet', 'debris', 'probe', 'meteor', 'astronaut', 'spiral_debris'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                let geometry, material, mesh;
                
                switch (type) {
                    case 'rocket':
                        geometry = new THREE.ConeGeometry(0.2, 1, 8);
                        material = new THREE.MeshPhongMaterial({ color: 0xff4444 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'ufo':
                        geometry = new THREE.SphereGeometry(0.5, 16, 8);
                        geometry.scale(1, 0.3, 1);
                        material = new THREE.MeshPhongMaterial({ color: 0x44ff44 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'asteroid':
                        geometry = new THREE.DodecahedronGeometry(0.5);
                        material = new THREE.MeshPhongMaterial({ color: 0x888888 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'satellite':
                        geometry = new THREE.BoxGeometry(0.3, 0.3, 0.8);
                        material = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'comet':
                        geometry = new THREE.SphereGeometry(0.3, 8, 6);
                        material = new THREE.MeshPhongMaterial({ color: 0x00aaff, transparent: true, opacity: 0.8 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'debris':
                        geometry = new THREE.OctahedronGeometry(0.4);
                        material = new THREE.MeshPhongMaterial({ color: 0x664422 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'probe':
                        geometry = new THREE.CylinderGeometry(0.2, 0.3, 0.8, 6);
                        material = new THREE.MeshPhongMaterial({ color: 0xff6600 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'meteor':
                        geometry = new THREE.IcosahedronGeometry(0.6);
                        material = new THREE.MeshPhongMaterial({ color: 0xaa4444, roughness: 0.8 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'astronaut':
                        // Create a simple astronaut shape (head + body)
                        const astronautGroup = new THREE.Group();
                        // Head
                        const headGeometry = new THREE.SphereGeometry(0.2, 8, 6);
                        const headMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        const head = new THREE.Mesh(headGeometry, headMaterial);
                        head.position.y = 0.3;
                        astronautGroup.add(head);
                        // Body
                        const bodyGeometry = new THREE.CylinderGeometry(0.15, 0.2, 0.6, 8);
                        const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                        astronautGroup.add(body);
                        mesh = astronautGroup;
                        break;
                    case 'spiral_debris':
                        // Create a big red debris with jagged edges
                        geometry = new THREE.IcosahedronGeometry(1.2); // Much bigger
                        material = new THREE.MeshPhongMaterial({ 
                            color: 0xcc2222, // Strong red
                            roughness: 0.9,
                            metalness: 0.1
                        });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                }
                
                // Set position and movement based on type
                if (type === 'spiral_debris') {
                    // Big red debris moves slower and spirals
                    mesh.position.set(
                        (Math.random() - 0.5) * 35,
                        (Math.random() - 0.5) * 35,
                        -70 // Start even further back
                    );
                    mesh.userData = { 
                        type: type,
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.03, // Very slow horizontal movement
                            (Math.random() - 0.5) * 0.03,
                            Math.random() * 0.06 + 0.03   // Very slow forward movement
                        ),
                        rotation: new THREE.Vector3(
                            Math.random() * 0.008,
                            Math.random() * 0.008,
                            Math.random() * 0.008
                        ),
                        spiralTime: 0, // For spiral movement
                        spiralRadius: Math.random() * 3 + 2, // Bigger spiral
                        spiralSpeed: 0.02 // Slower spiral
                    };
                } else if (type === 'astronaut') {
                    // Astronaut moves normally now (no spiral)
                    mesh.position.set(
                        (Math.random() - 0.5) * 30,
                        (Math.random() - 0.5) * 30,
                        -60
                    );
                    mesh.userData = { 
                        type: type,
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.05, // Slower horizontal movement
                            (Math.random() - 0.5) * 0.05,
                            Math.random() * 0.08 + 0.04   // Slower forward movement
                        ),
                        rotation: new THREE.Vector3(
                            Math.random() * 0.01,
                            Math.random() * 0.01,
                            Math.random() * 0.01
                        )
                    };
                } else {
                    // Regular objects
                    mesh.position.set(
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 40,
                        -50
                    );
                    mesh.userData = { 
                        type: type,
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1,
                            Math.random() * 0.2 + 0.1
                        ),
                        rotation: new THREE.Vector3(
                            Math.random() * 0.02,
                            Math.random() * 0.02,
                            Math.random() * 0.02
                        )
                    };
                }
                
                this.scene.add(mesh);
                this.flyingObjects.push(mesh);
                
                // Remove after it's far away
                setTimeout(() => {
                    this.scene.remove(mesh);
                    const index = this.flyingObjects.indexOf(mesh);
                    if (index > -1) {
                        this.flyingObjects.splice(index, 1);
                    }
                }, 30000);
            }

            spawnHorizontalObject() {
                const types = ['rocket', 'ufo', 'satellite', 'debris'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                let geometry, material, mesh;
                
                switch (type) {
                    case 'rocket':
                        geometry = new THREE.ConeGeometry(0.2, 1, 8);
                        material = new THREE.MeshPhongMaterial({ color: 0xff4444 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'ufo':
                        geometry = new THREE.SphereGeometry(0.5, 16, 8);
                        geometry.scale(1, 0.3, 1);
                        material = new THREE.MeshPhongMaterial({ color: 0x44ff44 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'satellite':
                        geometry = new THREE.BoxGeometry(0.3, 0.3, 0.8);
                        material = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'debris':
                        geometry = new THREE.OctahedronGeometry(0.4);
                        material = new THREE.MeshPhongMaterial({ color: 0x664422 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                }
                
                // Start from left-back, move to right-front
                mesh.position.set(
                    -40, // Far left
                    (Math.random() - 0.5) * 20, // Random height
                    -30  // Back
                );
                
                mesh.userData = { 
                    type: type,
                    velocity: new THREE.Vector3(
                        Math.random() * 0.3 + 0.2, // Move right
                        (Math.random() - 0.5) * 0.05, // Slight vertical movement
                        Math.random() * 0.1 + 0.1   // Move toward camera
                    ),
                    rotation: new THREE.Vector3(
                        Math.random() * 0.02,
                        Math.random() * 0.02,
                        Math.random() * 0.02
                    ),
                    isHorizontal: true // Mark as horizontal object
                };
                
                this.scene.add(mesh);
                this.flyingObjects.push(mesh);
                
                // Remove after it's far away
                setTimeout(() => {
                    this.scene.remove(mesh);
                    const index = this.flyingObjects.indexOf(mesh);
                    if (index > -1) {
                        this.flyingObjects.splice(index, 1);
                    }
                }, 15000); // 15 seconds for horizontal objects
            }

            spawnHorizontalObjectReverse() {
                const types = ['rocket', 'ufo', 'satellite', 'debris', 'comet'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                let geometry, material, mesh;
                
                switch (type) {
                    case 'rocket':
                        geometry = new THREE.ConeGeometry(0.2, 1, 8);
                        material = new THREE.MeshPhongMaterial({ color: 0xff4444 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'ufo':
                        geometry = new THREE.SphereGeometry(0.5, 16, 8);
                        geometry.scale(1, 0.3, 1);
                        material = new THREE.MeshPhongMaterial({ color: 0x44ff44 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'satellite':
                        geometry = new THREE.BoxGeometry(0.3, 0.3, 0.8);
                        material = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'debris':
                        geometry = new THREE.OctahedronGeometry(0.4);
                        material = new THREE.MeshPhongMaterial({ color: 0x664422 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    case 'comet':
                        geometry = new THREE.SphereGeometry(0.3, 8, 6);
                        material = new THREE.MeshPhongMaterial({ color: 0x00aaff, transparent: true, opacity: 0.8 });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                }
                
                // Start from right-back, move to left-front
                mesh.position.set(
                    40, // Far right
                    (Math.random() - 0.5) * 20, // Random height
                    -30  // Back
                );
                
                mesh.userData = { 
                    type: type,
                    velocity: new THREE.Vector3(
                        -(Math.random() * 0.3 + 0.2), // Move left (negative)
                        (Math.random() - 0.5) * 0.05, // Slight vertical movement
                        Math.random() * 0.1 + 0.1   // Move toward camera
                    ),
                    rotation: new THREE.Vector3(
                        Math.random() * 0.02,
                        Math.random() * 0.02,
                        Math.random() * 0.02
                    ),
                    isHorizontalReverse: true // Mark as reverse horizontal object
                };
                
                this.scene.add(mesh);
                this.flyingObjects.push(mesh);
                
                // Remove after it's far away
                setTimeout(() => {
                    this.scene.remove(mesh);
                    const index = this.flyingObjects.indexOf(mesh);
                    if (index > -1) {
                        this.flyingObjects.splice(index, 1);
                    }
                }, 15000); // 15 seconds for horizontal objects
            }

            createFartParticles(position) {
                const particleCount = 50;
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const velocities = [];
                
                for (let i = 0; i < particleCount; i++) {
                    // Start near the planet
                    positions.push(
                        position.x + (Math.random() - 0.5) * 2,
                        position.y + (Math.random() - 0.5) * 2,
                        position.z + (Math.random() - 0.5) * 2
                    );
                    
                    // Random velocities
                    velocities.push(
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2
                    );
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: 0x88ff88,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.8
                });
                
                const particles = new THREE.Points(geometry, material);
                particles.userData = { 
                    velocities: velocities,
                    life: 2.0
                };
                
                this.scene.add(particles);
                this.particles.push(particles);
            }

            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    const positions = particle.geometry.attributes.position.array;
                    const velocities = particle.userData.velocities;
                    
                    for (let j = 0; j < positions.length; j += 3) {
                        positions[j] += velocities[j];
                        positions[j + 1] += velocities[j + 1];
                        positions[j + 2] += velocities[j + 2];
                    }
                    
                    particle.geometry.attributes.position.needsUpdate = true;
                    particle.userData.life -= 0.016;
                    particle.material.opacity = particle.userData.life / 2.0;
                    
                    if (particle.userData.life <= 0) {
                        this.scene.remove(particle);
                        this.particles.splice(i, 1);
                    }
                }
            }

            setupEventListeners() {
                window.addEventListener('resize', () => this.onWindowResize());
                window.addEventListener('click', (event) => this.onMouseClick(event));
                window.addEventListener('mousemove', (event) => this.onMouseMove(event));
                
                document.getElementById('muteBtn').addEventListener('click', () => this.toggleMute());
                document.getElementById('leaderboardToggle').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleLeaderboard();
                });
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            onMouseMove(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }

            onMouseClick(event) {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                
                if (intersects.length > 0) {
                    const clickedObject = intersects[0].object;
                    
                    if (clickedObject.userData.type === 'uranus' || clickedObject.parent?.userData.type === 'uranus') {
                        this.touchUranus(intersects[0].point);
                    } else if (clickedObject.userData.type === 'cat' || clickedObject.parent?.userData.type === 'cat') {
                        this.touchCat(intersects[0].point);
                    } else if (clickedObject.userData.type === 'pumpkid' || clickedObject.parent?.userData.type === 'pumpkid') {
                        // Pumpkid is not clickable - do nothing
                        console.log('Pumpkid clicked but not interactive');
                    } else if (clickedObject.userData.type === 'ass' || clickedObject.parent?.userData.type === 'ass') {
                        this.touchAss(intersects[0].point);
                    } else if (clickedObject.userData.type === 'fire' || clickedObject.parent?.userData.type === 'fire') {
                        this.touchFire(intersects[0].point);
                    } else if (!clickedObject.userData.nonInteractive) {
                        // Clicked on flying object (but not stars or other non-interactive objects)
                        this.explodeObject(clickedObject, intersects[0].point);
                    }
                }
            }

            playFartSound() {
                if (this.isMuted) return;

                try {
                    // Play the real fart sound
                    if (this.fartAudio) {
                        this.fartAudio.currentTime = 0; // Reset to beginning
                        this.fartAudio.play().catch(error => {
                            console.log('Audio play failed:', error);
                            // Fallback to synthetic sound
                            this.playSyntheticFartSound();
                        });
                    } else {
                        // Fallback to synthetic sound
                        this.playSyntheticFartSound();
                    }
                } catch (error) {
                    console.log('Audio playback failed:', error);
                    this.playSyntheticFartSound();
                }
            }
            
            playSyntheticFartSound() {
                if (this.isMuted || !this.audioContext) return;
                
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(80, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(40, this.audioContext.currentTime + 0.3);
                        
                        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                        
                        oscillator.type = 'sawtooth';
                oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.3);
                    }

            touchUranus(point) {
                this.fartCount++;
                this.updateCounter();
                this.saveProgress();
                
                // Add to global leaderboard
                this.incrementGlobalCount();
                
                // Only sound and animation - no particles or shake
                this.playFartSound();
                this.playClickAnimation();
                
                // Check for special events
                this.checkEasterEggs();
            }

            touchCat(point) {
                console.log('Cat clicked!');
                
                // Play slap sound instantly
                this.playSlapSound();
                
                // Trigger cat animation
                this.playCatClickAnimation();
                
                // Simultaneously trigger pumpkid animation (only pumpkid moves with cat)
                this.playPumpkidClickAnimation();
            }

            touchAss(point) {
                console.log('Ass clicked!');
                
                // Play ass burning sound instantly
                this.playAssBurningSound();
                
                // Trigger ass animation only
                this.playAssAnimation();
            }

            touchFire(point) {
                console.log('Fire clicked!');
                
                // Play fire burning sound instantly
                this.playFireBurningSound();
                
                // Trigger fire animation only
                this.playFireAnimation();
            }

            playSlapSound() {
                if (this.isMuted) return;

                try {
                    // Play the slap sound
                    if (this.slapAudio) {
                        this.slapAudio.currentTime = 0; // Reset to beginning
                        this.slapAudio.play().catch(error => {
                            console.log('Slap audio play failed:', error);
                        });
                    }
                } catch (error) {
                    console.log('Slap audio playback failed:', error);
                }
            }

            playAssBurningSound() {
                if (this.isMuted) return;

                try {
                    // Play the ass burning sound
                    if (this.assBurningAudio) {
                        this.assBurningAudio.currentTime = 0; // Reset to beginning
                        this.assBurningAudio.play().catch(error => {
                            console.log('Ass burning audio play failed:', error);
                        });
                    }
                } catch (error) {
                    console.log('Ass burning audio playback failed:', error);
                }
            }

            playFireBurningSound() {
                if (this.isMuted) return;

                try {
                    // Play the fire burning sound
                    if (this.fireBurningAudio) {
                        this.fireBurningAudio.currentTime = 0; // Reset to beginning
                        this.fireBurningAudio.play().catch(error => {
                            console.log('Fire burning audio play failed:', error);
                        });
                    }
                } catch (error) {
                    console.log('Fire burning audio playback failed:', error);
                }
            }

            explodeObject(object, point) {
                // Remove the object
                this.scene.remove(object);
                const index = this.flyingObjects.indexOf(object);
                if (index > -1) {
                    this.flyingObjects.splice(index, 1);
                }
                
                // Create explosion (PNG or particles)
                this.createExplosion(point);
                this.playExplosionSound();
                
                // Play custom explosion sound if available
                this.playCustomExplosionSound();
                
                // Show emoji explosion
                this.showEmojiExplosion(['üí•', '‚≠ê', '‚ú®', 'üî•'][Math.floor(Math.random() * 4)]);
            }

            createExplosion(position) {
                // Create PNG explosion instead of particles
                // First create a plane for the explosion image
                const explosionGeometry = new THREE.PlaneGeometry(3, 3);
                
                // Try to load explosion PNG, fallback to particles if not found
                const explosionTexture = new THREE.TextureLoader().load(
                    'Assets/explosion.png', // You'll add this PNG file
                    // On successful load
                    (texture) => {
                        console.log('Explosion PNG loaded successfully');
                    },
                    // On progress
                    undefined,
                    // On error - fallback to particle explosion
                    (error) => {
                        console.log('Explosion PNG not found, using particle explosion');
                        this.createParticleExplosion(position);
                        return;
                    }
                );
                
                const explosionMaterial = new THREE.MeshBasicMaterial({
                    map: explosionTexture,
                    transparent: true,
                    alphaTest: 0.1
                });
                
                const explosionMesh = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosionMesh.position.copy(position);
                
                // Make it face the camera
                explosionMesh.lookAt(this.camera.position);
                
                // Add to scene
                this.scene.add(explosionMesh);
                
                // Animate the explosion (scale up then fade out)
                explosionMesh.scale.set(0.1, 0.1, 0.1);
                
                const animateExplosion = () => {
                    const scale = explosionMesh.scale.x;
                    const opacity = explosionMaterial.opacity;
                    
                    if (scale < 1) {
                        // Scale up
                        explosionMesh.scale.multiplyScalar(1.1);
                        requestAnimationFrame(animateExplosion);
                    } else if (opacity > 0) {
                        // Fade out
                        explosionMaterial.opacity -= 0.05;
                        requestAnimationFrame(animateExplosion);
                    } else {
                        // Remove
                        this.scene.remove(explosionMesh);
                    }
                };
                
                requestAnimationFrame(animateExplosion);
            }
            
            createParticleExplosion(position) {
                // Fallback particle explosion
                const particleCount = 30;
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const velocities = [];
                
                for (let i = 0; i < particleCount; i++) {
                    positions.push(position.x, position.y, position.z);
                    
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5
                    );
                    velocities.push(velocity.x, velocity.y, velocity.z);
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: 0xff8800,
                    size: 0.2,
                    transparent: true
                });
                
                const explosion = new THREE.Points(geometry, material);
                explosion.userData = { 
                    velocities: velocities,
                    life: 1.0
                };
                
                this.scene.add(explosion);
                this.particles.push(explosion);
            }

            shakeCamera() {
                // Simple camera shake without Motion One
                const originalPosition = this.camera.position.clone();
                const shakeIntensity = 0.2;
                const shakeDuration = 300; // ms
                const shakeSteps = 10;
                const stepDuration = shakeDuration / shakeSteps;
                
                let step = 0;
                const shakeInterval = setInterval(() => {
                    if (step < shakeSteps) {
                        // Random shake
                        this.camera.position.x = originalPosition.x + (Math.random() - 0.5) * shakeIntensity;
                        this.camera.position.y = originalPosition.y + (Math.random() - 0.5) * shakeIntensity * 0.5;
                        step++;
                    } else {
                        // Return to original position
                        this.camera.position.copy(originalPosition);
                        clearInterval(shakeInterval);
                    }
                }, stepDuration);
            }

            showEmojiExplosion(emoji) {
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const emojiEl = document.createElement('div');
                        emojiEl.className = 'emoji-explosion';
                        emojiEl.textContent = emoji;
                        emojiEl.style.left = Math.random() * window.innerWidth + 'px';
                        emojiEl.style.top = Math.random() * window.innerHeight + 'px';
                        document.body.appendChild(emojiEl);
                        
                        if (window.motion && window.motion.animate) {
                            window.motion.animate(emojiEl, 
                                { 
                                    scale: [0, 2, 0],
                                    rotate: [0, 360],
                                    opacity: [0, 1, 0]
                                },
                                { duration: 1.5, ease: "ease-out" }
                            ).finished.then(() => {
                                emojiEl.remove();
                            });
                        } else {
                            // Fallback without motion library
                            setTimeout(() => emojiEl.remove(), 1500);
                        }
                    }, i * 100);
                }
            }

            checkEasterEggs() {
                if (this.fartCount === 69) {
                    this.showEmojiExplosion('üçë');
                    this.playSpecialSound();
                } else if (this.fartCount === 100) {
                    this.enterUranusMode();
                } else if (this.fartCount === 420) {
                    this.showEmojiExplosion('üåø');
                    this.createRainbowEffect();
                }
            }

            enterUranusMode() {
                if (this.isInsideUranus) return;
                
                this.isInsideUranus = true;
                this.showEmojiExplosion('üöÄ');
                
                // Zoom camera into planet
                if (window.motion && window.motion.animate) {
                    window.motion.animate(this.camera.position, 
                        { z: 0.5 },
                        { duration: 3, ease: "ease-in-out" }
                    ).finished.then(() => {
                        // Show inside Uranus for a moment
                setTimeout(() => {
                            window.motion.animate(this.camera.position, 
                                { z: 10 },
                                { duration: 2, ease: "ease-out" }
                            ).finished.then(() => {
                                this.isInsideUranus = false;
                            });
                }, 2000);
                    });
                } else {
                    // Fallback without motion library
                    console.log('Motion library not available for Uranus mode');
                    this.camera.position.z = 0.5;
                    setTimeout(() => {
                        this.camera.position.z = 10;
                        this.isInsideUranus = false;
                    }, 5000);
                }
            }

            createRainbowEffect() {
                // Change the planet colors temporarily
                const originalColor = this.uranusPlanet.material.color.clone();
                const colors = [0xff0000, 0xff8800, 0xffff00, 0x00ff00, 0x0088ff, 0x4400ff, 0x8800ff];
                
                let colorIndex = 0;
                const interval = setInterval(() => {
                    this.uranusPlanet.material.color.setHex(colors[colorIndex]);
                    colorIndex = (colorIndex + 1) % colors.length;
                }, 200);
                
                setTimeout(() => {
                    clearInterval(interval);
                    this.uranusPlanet.material.color.copy(originalColor);
                }, 3000);
            }

            playExplosionSound() {
                if (this.isMuted || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.5, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                
                oscillator.type = 'square';
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.2);
            }
            
            playCustomExplosionSound() {
                if (this.isMuted) return;
                
                try {
                    // Play custom explosion sound if available
                    if (this.explosionAudio && this.explosionAudio.readyState >= 2) {
                        this.explosionAudio.currentTime = 0;
                        this.explosionAudio.play().catch(error => {
                            console.log('Custom explosion audio play failed:', error);
                        });
                    }
                } catch (error) {
                    console.log('Custom explosion audio playback failed:', error);
                }
            }

            playSpecialSound() {
                if (this.isMuted || !this.audioContext) return;
                
                // Play a sequence of tones
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(200 + i * 100, this.audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                        
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.2);
                    }, i * 150);
                }
            }

            updateCounter() {
                document.getElementById('fart-counter').textContent = `üí® ${this.fartCount}`;
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                document.getElementById('muteBtn').textContent = this.isMuted ? 'üîá' : 'üîä';
            }

            toggleLeaderboard() {
                const leaderboard = document.getElementById('leaderboard');
                const toggleBtn = document.getElementById('leaderboardToggle');
                const isCollapsed = leaderboard.classList.contains('collapsed');
                
                if (isCollapsed) {
                    // Expand - show full leaderboard
                    leaderboard.classList.remove('collapsed');
                    toggleBtn.textContent = '‚ñ≤';
                } else {
                    // Collapse - show only preview
                    leaderboard.classList.add('collapsed');
                    toggleBtn.textContent = '‚ñº';
                }
            }

            saveProgress() {
                localStorage.setItem('uranusProgress', JSON.stringify({
                    farts: this.fartCount
                }));
            }

            loadProgress() {
                const saved = localStorage.getItem('uranusProgress');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.fartCount = data.farts || 0;
                    this.updateCounter();
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update flying objects
                for (const obj of this.flyingObjects) {
                    if (obj.userData.type === 'spiral_debris') {
                        // Special slow spiral movement for big red debris
                        obj.userData.spiralTime += obj.userData.spiralSpeed; // Slower spiral
                        obj.position.x += Math.sin(obj.userData.spiralTime) * 0.08;
                        obj.position.y += Math.cos(obj.userData.spiralTime) * 0.08;
                        obj.position.z += obj.userData.velocity.z;
                        // Slow menacing rotation
                        obj.rotation.x += 0.015;
                        obj.rotation.y += 0.010;
                        obj.rotation.z += 0.008;
                    } else {
                        // Regular movement for other objects (including astronaut)
                        obj.position.add(obj.userData.velocity);
                        obj.rotation.x += obj.userData.rotation.x;
                        obj.rotation.y += obj.userData.rotation.y;
                        obj.rotation.z += obj.userData.rotation.z;
                    }
                }
                
                // Update particles
                this.updateParticles();
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Copy contract address function
        function copyContractAddress() {
            const contractAddress = 'BFgdzMkTPdKKJeTipv2njtDEwhKxkgFueJQfJGt1jups';
            
            // Try modern clipboard API first
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(contractAddress).then(() => {
                    showCopyNotification();
                }).catch(() => {
                    // Fallback to older method
                    fallbackCopyToClipboard(contractAddress);
                });
            } else {
                // Fallback for older browsers
                fallbackCopyToClipboard(contractAddress);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                showCopyNotification();
            } catch (err) {
                console.log('Copy failed:', err);
            }
            
            document.body.removeChild(textArea);
        }
        
        function showCopyNotification() {
            const notification = document.getElementById('copyNotification');
            notification.style.opacity = '1';
            
            setTimeout(() => {
                notification.style.opacity = '0';
            }, 2000);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new UranusUniverse();
        });

        // Enable audio on first click
        document.addEventListener('click', function enableAudio() {
            if (window.AudioContext || window.webkitAudioContext) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const audioContext = new AudioContext();
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }
            document.removeEventListener('click', enableAudio);
        }, { once: true });
    </script>
</body>
</html>